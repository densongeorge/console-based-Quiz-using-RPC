/* 

 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "quiz.h"
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#define MAXCLIENT 50

//global variable for active user
int active=0;

int que[4][10]={{3,4,2,5,6,7,8,9,10,1},
		{4,5,6,3,7,8,9,10,1,2},
		{8,9,10,1,2,3,7,4,5,6},
		{1,2,3,4,5,6,7,8,9,10}};

//global structure for question
struct question  
{ 
	int qno; 
	char q[500];
	char answer[100];  
};

//global structure for keeping track of the clients
typedef struct{
	char id[512];
	int qno;
	int score;
	int seq[50];
	//some more fields here
} user_info;

user_info user[MAXCLIENT]={}; // will save state of upto 200 clients

//sort the structure array
//
void bsortDesc(user_info list[], int s)
{
    int i, j;
    user_info temp;

    for (i = 0; i < s - 1; i++)
    {
        for (j = 0; j < (s - 1-i); j++)
        {
            if (list[j].score < list[j + 1].score)
            {
                temp = list[j];
                list[j] = list[j + 1];
                list[j + 1] = temp;
            }
        }
    }
}

     
//to check if client exists in active list
int check_cl(user_info input[],char id[]) 
{
	int found =0;
	int pos=0;
	for(int i =0;i<MAXCLIENT-1;i++)
	{
		if(strcmp(input[i].id,id)==0)
		{
			found =1;
			pos=i;
			break;
		}
	}
	if(found==1)
		return pos;
	else
		return -1;
}

//to get relative position
int getpos(user_info input[],char id[])
{
	int found =0;
	int pos=1;
	for(int i =0;i<MAXCLIENT-1;i++)
	{
		if(strcmp(input[i].id,id)==0)
		{
			found =1;
			break;
		}

		if(input[i].score>input[i+1].score)
		{
			pos++;	
		}
	}
	if(found==1)
		return pos;
	else
		return -1;
}

//procedure for intial connection
quiz_sr_home *
quizproc_1_svc(quiz_cl_home *argp, struct svc_req *rqstp)
{
	static quiz_sr_home  result;
	bsortDesc(user,MAXCLIENT);

	int present=0;//check if client is present
        int presentIndex=0;
	presentIndex=check_cl(user,argp->id);

	if(presentIndex != -1)//client already exists means failed client so fetch its score and position
	{
		strcpy(result.id,user[presentIndex].id);
		result.pos=getpos(user,user[presentIndex].id);
		result.score=user[presentIndex].score;
		present=1;
		printf("client: %s has reconnected!\n",result.id);
	}
		
	if(!present)
	{
		for(int i=0;i< MAXCLIENT;i++)
		{
			if(user[i].id[0]=='\0')//new client
			{
				strcpy(user[i].id,argp->id);
				strcpy(result.id,argp->id);
				active++;
				printf("\nNumber of active clients: %d\n",active);
				result.pos=i+1; //set last empty struct client's array index here.
				user[i].score=0;
				result.score=user[i].score;
				int temp=0;
				//set sequence for question
				for(int j=0;j<50;j++)
				{
					  if(j%10 == 0 && j!=0)
                                                temp=temp+10;
					  user[i].seq[j]=temp+que[active%4][j%10];
				}

				printf("New client %s has connected!\n",result.id);

				break;
			}
		}
		
	}

	return &result;
}

//procedure for asking question
quiz_sr_que *
quizquestionproc_1_svc(quiz_cl_req *argp, struct svc_req *rqstp)
{
	static quiz_sr_que  result;
	static struct question input;
	static int i=0;
	int temp=1;
	
	bsortDesc(user,MAXCLIENT);	
	FILE *infile; 
    	
        int presentIndex=check_cl(user,argp->id);

	if(presentIndex != -1)//client already exists means failed client so fetch its score 
	{
		strcpy(result.id,user[presentIndex].id);
	}
	

	// Open person.dat for reading 
	infile = fopen ("question_answer.dat", "r"); 

	if (infile == NULL) 
        { 
    	    fprintf(stderr, "\nError opening file\n"); 
            exit (1); 
    	} 
      
	//read a question from file..........
	while(temp<user[presentIndex].seq[user[presentIndex].qno])
	{
		fread(&input, sizeof(struct question), 1, infile);
		temp++;
	}
	fread(&input, sizeof(struct question), 1, infile);
	
	strcpy(result.question,input.q);
	result.que_no=user[presentIndex].seq[user[presentIndex].qno];
	fclose (infile); 

	return &result;
}


//procedure for checking answer
quiz_sr_reply *
replyproc_1_svc(quiz_cl_ans *argp, struct svc_req *rqstp)
{
	static quiz_sr_reply  result;	
	static struct question input;		
	int temp=1;
	
	bsortDesc(user,MAXCLIENT);
	int presentIndex=check_cl(user,argp->id);

	if(presentIndex != -1)//client already exists means failed client so fetch its score 
	{
		strcpy(result.id,user[presentIndex].id);
	}

	FILE *infile; 
     
	// Open person.dat for reading 
	infile = fopen ("question_answer.dat", "r"); 

	if (infile == NULL) 
        { 
    	    fprintf(stderr, "\nError opening file\n"); 
            exit (1); 
    	} 
	strcpy(result.id,argp->id);
	
	while(temp<argp->que_no)
	{
		fread(&input, sizeof(struct question), 1, infile);
		temp++;
	}
	fread(&input, sizeof(struct question), 1, infile);

	int res = strcmp(argp->answer,input.answer);
	if(!res)
	{
		user[presentIndex].score+=1;
		result.score=user[presentIndex].score;
		strcpy(result.reply,"right!");
	}
	else
	{
		result.score=user[presentIndex].score;
		strcpy(result.reply,"wrong!");
			
	}
	user[presentIndex].qno++;
	fclose (infile);

	return &result;
}

//procedure for getting the current position
quiz_sr_pos *
getpos_1_svc(quiz_cl_pos *argp, struct svc_req *rqstp)
{
	static quiz_sr_pos  result;

	bsortDesc(user,MAXCLIENT);
	result.pos=getpos(user,argp->id);

	return &result;
}

//procedure for displaying the leaderboard
quiz_sr_lboard *
getleaderboard_1_svc(quiz_cl_lboard *argp, struct svc_req *rqstp)
{
	static quiz_sr_lboard  result;
	bsortDesc(user,MAXCLIENT);
	int i=argp->index;
	strcpy(result.leader_id,user[i].id);
	result.leader_score=user[i].score;


	return &result;
}
//procedure for ending quiz
quiz_sr_end *
quizend_1_svc(quiz_cl_end *argp, struct svc_req *rqstp)
{
	static quiz_sr_end  result;
	bsortDesc(user,MAXCLIENT);
	int presentIndex=check_cl(user,argp->id);

	if(presentIndex != -1)//client already exists means failed client so fetch its score 
	{
		strcpy(result.id,user[presentIndex].id);
		result.score=user[presentIndex].score;
	}
	bsortDesc(user,MAXCLIENT);
	
	result.pos=getpos(user,user[presentIndex].id);
	
	//client remove
	strcpy(user[presentIndex].id,"\0");
	user[presentIndex].score=0;
	user[presentIndex].qno=0;
	for(int i=0;i<10;i++)
	{
		user[presentIndex].seq[i]=0;
	}
	active--;
	printf("client: %s has disconnected!\n",result.id);
	return &result;
}
